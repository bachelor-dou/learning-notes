

[TOC]



### 容器 VS 虚拟机

#### 容器

​		容器就像胶囊式公寓，所有隔间共享地基、电线水管等，即共享物理网卡、内存、CPU等，只有当他们之间需要通信时，才会采用容器层面的网桥，而对于其他硬件，可以简单的认为每个容器占有了限定范围内的资源、但不依赖于操作系统、运行应用程序的环境。

​		容器只是运行在宿主机上的一种特殊进程，多个容器之间使用的还是同一个宿主机的操作内核（与虚拟机相比，容器隔离的并不彻底，资源依然会被其他的容器占用）。容器通过`Namespace`和`Cgroups`技术对应用程序进程进行隔离和资源限制；**`Namespace`的作用是环境隔离，只让应用程序看到该`Namespace`内部的世界， 而`Cgroups`技术则是限制分配给进程的宿主机资源**。但对于宿主机来说，这些被隔离的进程与其他进程没有多大区别。

**容器技术核心： 就是通过约束和修改进程的动态表现，从而为其创造出一个边界；（**创建容器进程时，指定了这个进程所需要启用的一组Namespace参数，这样，容器只能看到当前Namespace所限定的资源、文件或配置等；所以使用docker时，并不是一个真正的Docker容器运行在宿主机里面，Docker项目帮助用户启动的仍然是原来的应用进程，只不过在创建这些进程时，Docker为它们加上了各种各样的Namespace参数，达到仿佛运行在容器内，与世隔绝的效果）。Namespace是”隔离“， 而Cgroups技术是“限制”，通过资源限制文件的形式限制容器的资源量（个人理解简述），具体参数为docker run 后面的各项参数，类似于yaml文件。



​		**容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。**

​		**容器是一个应用层抽象，用于将代码和依赖资源打包在一起。** **多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行** 。与虚拟机相比， **容器占用的空间较少**（容器镜像大小通常只有几十兆），**瞬间就能完成启动** 。

​		**虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。** 管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 **占用大量空间** 。而且 VM **启动也十分缓慢** 。

[Python-100-Days/Day91-100/92.Docker容器技术详解.md at master · jackfrued/Python-100-Days (github.com)](https://github.com/jackfrued/Python-100-Days/blob/master/Day91-100/92.Docker容器技术详解.md)

[Docker入门教程：本地打包docker镜像_docker打包镜像_cjcjccccc的博客-CSDN博客](https://blog.csdn.net/feifeiwud/article/details/126636051)

[Docker 教程 )](https://www.runoob.com/docker/docker-tutorial.html)





### #  多容器管理

​		如果要对项目中使用的多个容器进行自动配置，使得容器可以相互协作甚至实现复杂的调度，这就需要进行容器编排。

####      Docker Compose

​		可以通过安装Docker Compose工具来实现基于YAML文件的容器编排，YAML文件会定义一系列的容器以及容器运行时的属性，Docker Compose会根据这些配置来管理容器。

#### Kubernetes（K8S）

​		实际的生产环境中常常需要部署和管理多个协同工作的容器，**docker compose解决了多容器创建和管理的问题**，**但是实际项目中还需要Kubernetes（以下都简称为K8S）来提供一个跨主机集群的容器调度平台。K8S可以进行自动化容器的部署、扩展和操作，从而提供以容器为中心的基础架构**。该项目是谷歌在2014年启动的项目，建立在谷歌公司十余年运维经验的基础之上，而且谷歌自己的应用也是运行在容器上的。



### #	**Dockerfile**

​		[参考手册](https://docs.docker.com/engine/reference/builder/)

​	Dockerfile 描述了组装镜像的步骤，其中每条指令都是单独执行的。除了FROM指令，其他每一条指令都会在上一条指令所生成镜像的基础上执行，执行完后会生成一个新的镜像层，新的镜像层覆盖在原来的镜像之上从而形成了新的镜像。Dockerfile所生成的最终镜像就是在基础镜像上面叠加一层层的镜像层组件的。Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。

​		Dockerfile 中指令不区分大小写，以 “#” 开头的是注释行，而在其他位置出现的 “#” 会被当成参数



### #	同步容器内时间

```bash
docker cp /usr/share/zoneinfo/Asia/Shanghai gitlab:/etc/localtime
```

### #	docker run运行容器参数

- `-d`表示容器在后台运行（不产生输出到Shell）并返回容器的ID；
- `-p`是用来映射容器的端口到宿主机的端口，冒号前面是宿主机的端口，冒号后面是容器内部使用的端口；
- `--rm`表示容器停止后自动删除容器，例如执行命令`docker stop mynginx`后，容器就不复存在了；
- `--name`后面是自定义的容器名字；
- 在创建容器的过程中，需要用到nginx的镜像文件，镜像文件的下载是自动完成的，如果没有指定版本号，默认是最新版本（latest）
- `-v`（volume） 在创建容器时通过数据卷操作，将指定的文件夹映射到容器的某个目录中，
- `--link`参数用于给容器创建网络别名，添加链接到另一个容器。
- `-e username="ritchie"`设置环境变量；
- `-m` 设置容器使用内存最大值；

### Docker init 工具

​	快速创建dockerfiles、Docker-compose文件

[Docker init 工具](https://mp.weixin.qq.com/s/NQos_PaHdWPISh22WubXlQ)
